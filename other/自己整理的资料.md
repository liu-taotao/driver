**重点知识-(自己收集整理的面试题目)**
* 1.什么是野指针
> 就是没有初始化的指针

* 2.`进程间通信`（Inter-Process Communication，IPC）是不同进程之间进行数据交换和共享资源的机制。
> 1.**管道**
> 2.**共享内存**
> 3.**信号量**
> 4.**消息队列**
> 5.**套接字**
> 6.**文件**

* 3.在Linux中，`共享资源`的保护通常使用各种同步机制来实现。
> 1.**自旋锁**
> 2.**互斥锁**
> 3.**读写锁**
> 4.**信号量**
> 5.**原子锁**
> 6.**屏障**

自旋锁（Spin Lock）：
- 用途：自旋锁用于保护临界区代码，当线程尝试获取锁时，如果锁已被其他线程占用，该线程会在一个循环中不断尝试获取锁，而不会阻塞等待。
- 特点和区别：自旋锁适用于对临界区的访问时间较短的情况，因为它在等待锁时会一直处于活跃状态，会消耗处理器资源。因此，自旋锁适用于多核CPU上的并发场景，可以避免线程切换的开销。

互斥锁（Mutex Lock）：
- 用途：互斥锁用于保护临界区代码，同一时间只允许一个线程获取锁，其他线程需要等待。
- 特点和区别：互斥锁提供了线程的阻塞和唤醒机制，当线程尝试获取锁时，如果锁已被占用，线程会被阻塞，直到锁被释放。互斥锁适用于对临界区的访问时间较长的情况，因为等待的线程会被置于休眠状态，不会消耗处理器资源。它适用于单核CPU和多核CPU上的并发场景。

读写锁（Read-Write Lock）：
- 用途：读写锁用于在读操作和写操作之间提供更好的并发性。多个线程可以同时持有读锁，但只允许一个线程持有写锁。
- 特点和区别：读写锁适用于对数据频繁读取而较少写入的场景，可以提高并发性和性能。当一个线程持有读锁时，其他线程也可以获取读锁，但写锁会阻塞所有的读锁和写锁。这样可以实现多个线程同时读取数据，但在写操作时需要独占锁。读写锁适用于读多写少的场景。

原子锁（Atomic Lock）：
- 用途：原子锁用于保护对共享资源的原子操作，确保操作的原子性。
- 特点和区别：原子锁通常是通过硬件的原子指令来实现的，能够提供高度的并发性。它与其他锁的区别在于，原子锁只能保护对共享资源的原子操作，而不能用于临界区的保护。原子锁通常是通过特定的原子操作（如原子比较和交换）来实现，不需要线程阻塞或唤醒的机制。



* 4.串口发送信息，20KB要发送多久，115200是什么，为什么要使用这个波特率

> 串口发送信息的速度可以通过波特率（baud rate）来衡量，它表示每秒传输的位数。波特率越高，传输速度越快。在串口通信中，波特率决定了每秒钟可以传输的位数，而不是字节数或数据包的大小。
>
> 假设你要发送20KB的数据，并且使用的是115200波特率。首先，我们需要将20KB转换为位数。由于1字节（byte）等于8位（bit），因此20KB等于20,000字节，即160,000位。然后，我们可以使用以下公式计算发送时间：
>
> 发送时间（秒）= 数据位数 / 波特率
>
> 发送时间（秒）= 160,000位 / 115200波特
>
> 计算结果约为1.39秒。
>
> 因此，如果使用115200波特率，发送20KB的数据大约需要1.39秒。
>
> 现在来解释一下115200是什么以及为什么要使用这个波特率。115200是一个常用的串口通信波特率，它表示每秒传输115200个位。它被广泛应用于许多串口设备和通信协议中。

* 5.memset()对于**int**类型数组的正确用法
```C
    //且memset()只能初始化为0/-1，其他不行的哦
    int hash[810];
    memset(hash, 0, sizeof(int)*810);//或者memset(hash, 0, sizeof(hash));
```



* 什么是物理地址和虚拟地址

  物理地址

  > 物理地址是指计算机内存中实际的硬件地址，也称为真实地址。每个计算机系统都有一组物理地址，它们对应着实际的内存位置。物理地址是由硬件（如内存管理单元）生成和使用的，用于在内存中定位和访问数据。

  虚拟地址

  >虚拟地址是在计算机系统中使用的抽象地址，也称为逻辑地址。虚拟地址空间是由操作系统分配给每个进程的独立地址空间。虚拟地址是相对于进程而言的，并不直接对应着物理内存的位置。当程序访问虚拟地址时，操作系统会将其转换为对应的物理地址，以实际访问内存中的数据。

### 2.c库函数(刷题总结)

* **1.strtok()**
> 原型: `char *strtok(char *str, const char *delimiters);`
[这里是完成的全部注释和解释算法，这个c库函数和栈的用法](../arithmetic/23.栈的简化路径/简化路径.c)
```c
/*
strtok函数将字符串str按照指定的分隔符delimiters进行分割，
并返回分割后的子字符串。该函数会修改传入的字符串，将
分隔符替换为\0（空字符），并返回指向分割后的第一个子字符串的指针。
在后续调用strtok时，可以通过将第一个参数str设为NULL来继续分割剩余的部分。
*/
#include <stdio.h>
#include <string.h>

int main() {
    char str[] = "Hello, World! How are you?";
    const char delimiters[] = " ,!";

    // 第一次调用strtok
    char *token = strtok(str, delimiters);
    while (token != NULL) {
        printf("%s\n", token);
        // 后续调用strtok
        token = strtok(NULL, delimiters);
    }

    return 0;
}
/*
在上述示例中，我们使用strtok函数将字符串str按照空格、逗号和感叹号进行分割。
每次调用strtok函数，它会返回分割后的子字符串，并将原字符串中的分隔符替换为\0。
通过在循环中反复调用strtok(NULL, delimiters)，
我们可以逐个获取分割后的子字符串并打印输出。
*/
```
* **2.strcmp()**
> 原型: `int strcmp(const char *str1, const char *str2);`
```c
/*
strcmp函数接受两个字符串作为参数，str1和str2，并返回一个整数值来表示比较结果。
返回值的含义如下：

* 如果str1等于str2，则返回值为0。
* 如果str1小于str2，则返回值小于0。
* 如果str1大于str2，则返回值大于0。
strcmp函数按照字典顺序逐个比较两个字符串的字符，
直到找到不同的字符或其中一个字符串的结束符（\0）为止。
比较是按照字符的ASCII值进行的。
*/
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "Hello";
    char str2[] = "Hello";
    char str3[] = "World";

    int result1 = strcmp(str1, str2);
    printf("strcmp(str1, str2) 返回值：%d\n", result1);

    int result2 = strcmp(str1, str3);
    printf("strcmp(str1, str3) 返回值：%d\n", result2);

    int result3 = strcmp(str3, str1);
    printf("strcmp(str3, str1) 返回值：%d\n", result3);

    return 0;
}

```
* **3.strcat()**
> 原型: `char *strcat(char *str1, const char *str2);`
```c
/*
strcat函数接受两个字符串作为参数，str1和str2，并将str2的内容追加到str1的末尾。
函数返回一个指向拼接后的字符串的指针，即指向str1的地址。

需要注意的是，str1必须具有足够的空间来容纳拼接后的字符串，
否则会导致缓冲区溢出的问题。
*/
#include <stdio.h>
#include <string.h>

int main() {
    char str1[20] = "Hello";
    const char str2[] = ", World!";

    strcat(str1, str2);

    printf("拼接后的字符串：%s\n", str1);

    return 0;
}
/*
需要注意的是，strcat函数假设str1的末尾是以空字符(\0)结尾的，
因此在调用strcat之前，str1必须是一个以空字符结尾的有效字符串。

如果需要将多个字符串进行拼接，可以连续调用strcat函数，
将每个字符串依次追加到目标字符串的末尾。
*/
```